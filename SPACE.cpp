/*
2.4. Космический путь
Экспедиция готовится отправиться в путь на космическом корабле нового поколения. Планируется последовательно посетить N планет звездной системы: от планеты Земля до планеты Победа. 
Планеты пронумерованы от 1 до N в порядке их посещения, Земля имеет номер 1, а Победа - номер N.
Для перелёта между планетами корабль может использовать любой тип топлива, существующий в звездной системе. Перед началом экспедиции корабль находится на планете Земля, и бак корабля пуст. 
Существующие типы топлива пронумерованы целыми числами, на планете с номером i можно заправиться только топливом типа ai. При посещении i-й планеты можно заправиться, полностью освободив бак
от имеющегося топлива и заполнив его топливом типа ai.
На каждой планете станция заправки устроена таким образом, что в бак заправляется ровно столько топлива, сколько потребуется для перелета до следующей планеты с топливом такого же типа.
Если далее такой тип топлива не встречается, заправляться на этой планете невозможно. Иначе говоря, после заправки на i-й планете топлива хватит для посещения планет от (i+1)-й до j-й включительно, 
где j -  минимальный номер планеты, такой что j > i и aj  = ai. Для продолжения экспедиции дальше j-й планеты корабль необходимо снова заправить на одной из этих планет.
Требуется написать программу, которая по заданным типам топлива на планетах определяет минимальное количество заправок, требуемых для экспедиции.
Ввод. В первой строке входного файла INPUT.TXT записано число N (2 ≤ N ≤ 300000) - количество планет. Во второй строке N целых чисел a1, a2, . . . , aN (2 ≤ ai ≤ 300000) - типы топлива на планетах.
Вывод. В первой строке выходного файла OUTPUT.TXT выведите единственное число K - минимальное количество заправок, которые нужно произвести. Во второй строке выведите K чисел, разделённых пробелами:
номера планет, на которых требуется заправиться. Номера планет требуется выводить в порядке времени заправок. Если решений с минимальным количеством заправок несколько, выведите любое из них. 
Если решения не существует, выведите число 0.
Примеры
Ввод 1             Ввод 2
7                  7
1 3 2 1 3 2 3      4 3 2 4 3 2 1
Вывод 1            Вывод 2
3                  0
1 3 5

Среда разработки: Visual Studio 2022
*/


#include <iostream>
#include <queue>
#include <vector>
using namespace std;

const int INF = 1000000000;
struct rebro
{
	int first;
	int second;
};
int main()
{
	int numVershine;
	cin >> numVershine;
	int kolReber = 0;
	vector<int> a;
	vector<rebro> adj;
	rebro drop;
	for (int i = 0; i < numVershine; i++)
	{
		a.push_back(0);
		cin >> a[i];
	}


	int last[1001] = { 0 };
	for (int i = 0; i < numVershine; i++)
	{
		a.push_back(0);
		cin >> a[i];
		if (last[a[i]] != 0)
		{
			adj.push_back(drop); 
			adj[kolReber].first = last[a[i]];
			adj[kolReber].second = i + 1;
			kolReber++;
			for (int k = last[a[i]] + 1; k < i; k++)
			{
				adj.push_back(drop); 
				adj[kolReber].first = last[a[i]];
				adj[kolReber].second = k + 1;
				kolReber++;
			}
		}
		last[a[i]] = i + 1;
	}


	vector<vector<int>> g(numVershine);
	for (int i = 0; i < kolReber; i++)
		g[adj[i].first - 1].push_back(adj[i].second - 1);
	int start = 0, finish = numVershine - 1;

	vector<int> dist(numVershine, INF); 
	dist[start] = 0; 
	vector<int> parent(numVershine, -1);

	queue<int> q;
	q.push(start); 

	while (!q.empty())
	{
		int u = q.front();
		q.pop();

		for (int v : g[u])
		{
			if (dist[v] == INF)
			{ 
				dist[v] = dist[u] + 1; 
				parent[v] = u; 
				q.push(v); 
			}
		}
	}
	if (dist[finish] == INF)
	{ 
		cout << "0" << endl;
	}
	else
	{
		cout << dist[finish] << endl;
		vector<int> path;
		for (int v = finish; v != -1; v = parent[v])
			path.push_back(v + 1);
		reverse(path.begin(), path.end());
		for (int i = 0; i < path.size() - 1; i++)
		{
			cout << path[i] << " ";
		}
		cout << endl;
	}
	return 0;
}